
import java.io.*;
import java.util.Scanner;

/**
 * @author Steven Dao
 * @version 1.4
 *
 * Date: 10/21/2021
 * Purpose: Performs a variety of miscellaneous functions.
 */
public class Functions {

    /**
     * Checks if the inputted value is an integer within the specified range (ex: 1-10)
     *
     * @param low  lower bound of the range
     * @param high upper bound of the range
     * @return the valid input
     */
    public static int checkIntRange(int low, int high) {
        // use a Scanner object to get user input
        Scanner in = new Scanner(System.in);
        // use a flag to determine when the user gives valid input
        boolean valid = false;
        // attempt to parse the input to ensure it is an integer
        int inputToInt = 0;

        while (!valid) {
            String input = in.nextLine();

            try {
                // if the input is not an int, it will trigger a NumberFormatException
                inputToInt = Integer.parseInt(input);

                // the range must be between the low and high input values
                if (inputToInt <= high && inputToInt >= low) {
                    valid = true;
                } else {
                    System.out.print("Input does not fall within the range; please try again: ");
                }
            } catch (NumberFormatException e) {
                System.out.print("Invalid input; please try again: ");
            }
        }
        return inputToInt;
    }

    /**
     * Replaces the byte at the given offset with the given byte.
     *
     * @param file the input file to seek/write from
     * @param inputOffset the given offset of which the byte will be replaced
     * @param inputHex the replacement byte in hexadecimal
     */
    public static void replaceByteAtOffset(File file, int inputOffset, String inputHex) {

        // use RandomAccessMemory to replace the bytes within the data file
        try (RandomAccessFile accessFile = new RandomAccessFile(file, "rw")) {
            // get the offset position
            accessFile.seek(inputOffset);
            // replace the bytes within the specified offset
            accessFile.write(Integer.parseInt(inputHex, 16));

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Prints all converted bytes as hexadecimal characters onto the system console.
     *
     * @param file the input file to convert bytes from
     */
    public static void printBytesAsHex(File file) {

        // store the bytes within an array given the byte length of the file
        byte[] bFile = new byte[(int) file.length()];

        // read from the input file
        try (FileInputStream in = new FileInputStream(file)) {
            // use the input reader to get the data from the file
            in.read(bFile);
            in.close();

            // keep track of the number of 2-bit registers read from
            int count = 0;

            // iterate through each byte to print to the console
            for (byte b : bFile) {
                int convertedByte = b;
                String byteToHex;

                // account for overflow past base-16
                if (b < 0)
                    convertedByte += 256;

                // convert the converted bytes to a padded hexadecimal String
                byteToHex = paddedToHex(convertedByte, 2);
                // increment the number of registers shown within the row
                ++count;

                // allow each row to have 16 register values before skipping to the next line
                if (count == 16) {
                    System.out.print(byteToHex + "\n");
                    count = 0;
                } else
                    System.out.print(byteToHex + " ");
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Pads leading zeros into the given byte using the input number of zeros.
     *
     * @param inputByte the input number of bytes
     * @param padCount the number of places this hexadecimal must have
     * @return the newly padded hexadecimal String
     */
    public static String paddedToHex(int inputByte, int padCount) {

        StringBuilder convertedByte = new StringBuilder();

        for (int i = padCount - 1; i > 0; --i) {
            // add a leading 0 for each padded count, if it needs one
            if (inputByte < Math.pow(16, i))
                convertedByte.append("0");
        }

        // return the rest of the String
        return convertedByte + Integer.toHexString(inputByte);
    }

    /**
     * Returns the converted hexadecimal using little Endian ordering.
     *
     * @param bigEndianString the hexadecimal in big Endian ordering
     * @return the converted String in little Endian ordering
     */
    public static String toLittleEndian(String bigEndianString) {

        // store the String within a StringBuilder to avoid excessive String object creation
        StringBuilder convertedString = new StringBuilder();
        // store the length to prevent excessive method calls within loops
        int stringLength = bigEndianString.length();

        // add each byte from right-to-left, starting from the end of the hexadecimal String
        for (int i = stringLength - 2; i >= 0; i -= 2) {
            convertedString.append(bigEndianString, i, i + 2);
        }

        // return the converted hexadecimal String in little Endian ordering
        return convertedString.toString();
    }
}
